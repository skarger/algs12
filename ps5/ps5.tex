\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{epstopdf}
\usepackage{algorithmic}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}



\title{}
\author{}
\date{}                                           % Activate to display a given date or no date

\begin{document}
\maketitle
%\section{}
%\subsection{}

\section{Trace Ford-Fulkerson algorithm}
The method of augmenting paths starts by finding an $s-t$ path. The edge on that path with smallest capacity dictates how much flow can move along the path. (Flow shown as dashed lines.) \\
\includegraphics [height=6cm] {g0.png}
\includegraphics [height=7cm] {g1.png} \\
It continues by finding additional $s-t$ paths and pushing as much flow as possible along them until there is no open path from $s$ to $t$ (subsequent residual networks on next page).
\includegraphics [height=8cm] {g2.png} 
\includegraphics [height=9cm] {g3.png} \\
\includegraphics [height=9cm] {g4.png} 
\includegraphics [height=9cm] {cut.png} \\
The min cut divides the vertices into the set $A$ reachable from $s$ and the set $B = V - A.$ The max flow is 8, which is the amount that crosses the min cut.
\section{Max flow reductions}
\begin{itemize}
\item Multiple sources and multiple sinks \\
\\
Denote the sources by $s_1, s_2, \dots, s_m$ and the sinks by $t_1, t_2, \dots, t_n$. The original max flow problem has only one source and one sink. Suppose we eliminated all sources and sinks except for $s_1$ and $t_1$ - then we would have an instance of the original max flow problem. Using the following algorithm we can do that sequentially for each source and sink.
\begin{algorithmic}
\STATE Initialize residual graph $G_f$ to be just the original network graph $G$.
\FORALL{$s_i$}
\FORALL{$t_j$}
\STATE Using the method of augmenting paths, determine the max flow from $s_i$ to $t_j$.
\ENDFOR
\ENDFOR
\end{algorithmic}

For this to work we must persist the residual graph $G_f$ across each iteration of the for loops, and use it as the starting network for each single source/sink max flow determination. Otherwise we would use the same units of flow multiple times. \\
\\
Note that when finding the max flow for a given source and sink $s_i, t_j$, we will never find a path through other sources or sinks. The other sources have no inbound edges, so a path starting at $s_i$ cannot reach them. Similarly, the other sinks have no outbound edges so it is impossible to find a path to $t_j$ that goes through another sink.

\item Both the edges and vertices have capacities \\
\\
The original max flow problem only has capacities on edges so we must convert the network to have that format.
\begin{algorithmic}
\FORALL{$u \in V$ besides $s$ and $t$}
\FORALL{outbound edges $(u,v)$}
\STATE Replace $(u,v)$ with two edges: $(u,u')$ and $(u',v)$
\STATE Set the capacity of $(u,u')$ to the capacity of vertex $u$
\STATE Set the capacity of $(u',v)$ to the capacity of the original edge $(u,v)$
\ENDFOR
\ENDFOR
\end{algorithmic}

After creating this new network we can use the augmenting path method for solving the original max flow problem. If necessary, during the conversion we could mark each edge as a ``vertex edge'' or an ``original edge'' so that we could return the final flows in the input format.

\end{itemize}

\section{Flow problem LPs}
\begin{itemize}
\item At each vertex, half the flow into the vertex is lost (or kept) at the vertex, and the other half flows out. The goal is to maximize the flow that reaches the destination $t$. \\
\\
First consider an example. \\
\includegraphics [height=7cm] {q3ex1.png} \\
We maintain the same capacity constraints on each edge as in the simple max-flow problem. The difference is that half the flow is lost at each vertex, or equivalently that the flow entering a vertex is equal to twice the flow leaving the vertex. Also the objective function changes to maximize the flow entering $t$ as opposed to maximizing what leaves $s$.
\begin{align*}
max\ & & & & f_{AT} & +f_{BT} & \\
& f_{SA} & & & & & \le 3 \\
& & f_{SB} & & & & \le 2 \\
& & & f_{AB} & & & \le 1 \\
& & & & f_{AT} & & \le 1 \\
& & & & & f_{BT} & \le 3 \\
& f_{SA} & & -2f_{AB} & -2f_{AT} & & = 0 \\
& & f_{SB} & +f_{AB} & & -2 f_{BT} & = 0 \\
& & & & & & f \ge 0
\end{align*}
The general case is similar: For every vertex $v$, add a constraint that the sum of flows entering $v$ is equal to 2 times the sum of flows leaving $v$.

\newpage
\item For each edge $e$, there is also a fixed cost $c_e$ for each unit of flow through the edge. We need to find the maximum flow with the minimum cost. \\
\\
First compute the max flow without edge costs using the LP discussed in class, namely,
\begin{itemize}
\item Add capacity constraints for each edge
\item Add conservation constraints such that $f_{in}(v) = f_{out}(v)$ for all vertices $v$ besides for $s$ and $t$.
\item Add a constraint that all flows must be non-negative
\item Maximize the flow from $s$ to $t$, represented by the sum of flows leaving $s$, $f_{out}(s)$.
\end{itemize}
Solving this LP derives a max flow value $M$. Next create a new LP to minimize the cost, utilizing $M$ and the edge costs $c_e$.
\begin{itemize}
\item Add a constraint that $f_{out}(s) = M$.
\item Use the same capacity, conservation, and non-negative constraints as in the original LP.
\item Minimize the sum $f_{e1}c_{e1} + f_{e2}c_{e2} + \cdots = \sum_{e \in E} f_e c_e$
\end{itemize}
\end{itemize}

\section{Algorithm to re-compute max flow}
Given: a maximum ßow in a graph $G = (V,E)$ with source $s$, sink $t$, and integer capacities. \\
\begin{itemize}
\item Suppose the capacity of a given edge $e$ is increased by 1. \\
The algorithm below computes the new max flow. \\
\\
Assumptions: The edge whose flow increased is known going in. If not, it can be determined in $O(|E|)$ time by comparing the original capacities of each edge to the current capacities. Call the vertices connected by this edge $u$ and $v$. \\
\begin{algorithmic}
\STATE Function MaybeIncreaseFlow
\STATE Using the given capacities and flow on $G$, resurrect the original residual graph $G_r$
\STATE Search for a path $P_{su}$ from $s$ to $u$ in $G_r$ using BFS
\IF{$u$ cannot be reached from $s$ given the available capacities}
\STATE Max flow does not change, return original values
\ENDIF
\STATE Search for a path $P_{vt}$ from $v$ to $t$ in $G_r$ using BFS
\IF{$t$ cannot be reached from $v$ given the available capacities}
\STATE Max flow does not change, return original values
\ENDIF
\STATE Add 1 unit of flow to each edge along $P_{su}$, $(u,v)$, and $P_{vt}$
\STATE Increment the max flow value by 1
\STATE End
\end{algorithmic}
Discussion: \\
Suppose the original min cut divides the vertices of $G$ into $(A,B)$. Even without the increased capacity on $(u,v)$ we can find a path to any vertex in $A$. Therefore if $u$ and $v$ are both in $A$ the increased capacity will not help. To increase the max flow, $(u,v)$ must connect a vertex in $A$ to a vertex in $B$; i.e. it must be on the min cut border. Conversely if $u \in B$ then the algorithm will fail to find the path $P_{su}$ and will return the original values. \\
\\
Furthermore, even if $(u,v)$ does connect $A$ to $B$ it is possible that we are still limited by the capacities of subsequent edges along the path from $v$ to $t$. That's why the algorithm must find the path $P_{vt}$ or return the original values. \\
\\
If we do find paths $P_{su}, P_{vt}$ then we know that $(u,v)$ completes a path that supports an additional unit of flow from $s$ to $t$. \\
Initially resurrecting $G_r$ and the flow updates at the end are $O(|E|)$. The two runs of BFS are $O(|V| + |E|)$.

\item Suppose the capacity of a given edge $e$ is decreased by 1. \\
The algorithm below computes the new max flow. I maintain the same assumption and notation stated above. \\
\begin{algorithmic}
\STATE Function MaybeDecreaseFlow
\STATE Using the given capacities and flow on $G$, resurrect the original residual graph $G_r$
\STATE Reduce the flow on $e = (u,v)$ by 1
\STATE Using BFS, search ``backwards'' from $t$ along edges with negative flow in $G_r$
\STATE Stop when vertex $v$ found. Set $P_{tv}$ := the path from $t$ to $v$
\STATE Decrement the (postive) flow on each edge along $P_{tv}$, updating $G_r$ accordingly
\STATE \ 
\STATE Using BFS, search ``backwards'' from $u$ along edges with negative flow in $G_r$
\FORALL{edges $e'$ encountered during the BFS above}
\IF{the flow on $e'$ = $c_{e'}$}
\STATE Reduce positive flow on $e'$ by 1 (push the flow back)
\IF{reached vertex $s$}
\STATE break
\ENDIF
\ELSE
\STATE Found an edge $e'$ where the flow on $e' < c_{e'}$ or
\STATE break
\ENDIF
\ENDFOR
\STATE Let the final edge considered by the BFS be $e' = (w,x)$
\STATE Assume that positive flow is directed from $w$ to $x$ (so in the BFS above $x$ would have been found before $w$)
\STATE Using BFS, search for a path $P_{xt}$ from $x$ to $t$ on $G_r$, taking into account the reduced capacity of $e$ as well as the reduced flow on edges between $x$ and $u$.
\IF {$P_{xt}$ found}
\STATE Push 1 unit of flow from $x$ to $t$ along $P_{xt}$, updating $G_r$ accordingly
\STATE Return the preserved original max flow value
\ELSE
\STATE Decrement the max flow value by 1
\ENDIF
\end{algorithmic}
Discussion: \\
The algorithm starts by decrementing the flow on $e$ and along a set of edges following $e$ to $t$. We might end up re-routing a unit of flow from $e$ back onto along some of those later edges, but as a starting point we clear it off. Note that we should always be able to find the ``backwards'' path $P_{tv}$ on the residual network because we have flow that can be pushed back. \\
\\
Then we search backwards again until finding an edge $(w,x)$ that is not filled to capacity. The point is to find a vertex $x$ on the min-cut border. If it turns out that it is possible re-route the flow as to preserve the original max flow, we will need do the re-routing ``forward'' of the min cut. We know that any new path starting from within $A$ (the min cut set including $s$) will not work, because we have already pushed as much flow as possible across the min cut. (As a side note, if both vertices of $e$ lie in $A$ then none of the existing flows are hampered by the decreased capacity, so the max flow remains the same.) \\
\\
The question is whether any path exists from $x$ to $t$ that can accomodate 1 unit of flow. Except for the edge $e$ whose capacity decreased, we know at least that we have the capacity to move a unit across all the edges from $x$ to $t$ where we decremented the flow, so we might end up re-using some of those. In particular, we will definitely use the edge that goes from $x$ back across the min cut, using the unit of flow we had freed during the for loop. However we also need at least one other edge with extra capacity in order to complete the needed path $P_{xt}$.
\\
\end{itemize}

\section{Matrix game}
Here are linear programs to maximize the value of the game for the row and column players. \\
Row player:
\begin{align*}
max\ z & \\
& z & - 3x_1 & - 6x_2 & + 3x_3 & + 7x_4 & \le 0 \\
& z & - x_1 & + 2x_2 & + 2x_3 & - 4x_4 & \le 0 \\
& z & & + 2x_2 & - 3x_3 & + 5x_4 & \le 0 \\
& z & + 4x_1 & & + 3x_3 & - 7x_4 & \le 0 \\
& & x_1 & + x_2 & + x_3 & + x_4 & = 1
\end{align*}
Column player:
\begin{align*}
min\ w & \\
& w & - 3y_1 & - y_2 & & + 4y_4 & \ge 0 \\
& w & - 6y_1 & + 2y_2 & + 2y_3 & & \ge 0 \\
& w & + 3y_1 & + 2y_2 & - 3y_3 & + 3y_4 & \ge 0 \\
& w & + 7y_1 & -4y_2 & + 5y_3 & - 7y_4 & \ge 0 \\
& & y_1 & + y_2 & + y_3 & + y_4 & = 1
\end{align*}
Solving these yields
\begin{equation*}
(z, x_1, x_2, x_3, x_4) = \left ( -\frac{224}{583}, \frac{8}{53}, \frac{161}{583}, \frac{221}{583}, \frac{113}{583} \right )
\end{equation*}
\begin{equation*}
(w, y_1, y_2, y_3, y_4) = \left ( -\frac{224}{583}, \frac{81}{583}, \frac{11}{53}, \frac{234}{583}, \frac{147}{583} \right )
\end{equation*}
\\
The proper strategy for the row player is choose row $i$ with the given probability for $x_i$ in the solution above. Likewise, the proper strategy for the column player is choose column $i$ with the given probability for $y_i$. \\
\\
The value of the game is thus $-\frac{224}{583}$, meaning on average the row player will pay the column player $\frac{224}{583}$ times the amount at stake in the game. Therefore to make it fair the column player should pay the row player to play, at a price equal to $\frac{224}{583}$ times the amount wagered. For instance if they bet \$1 each game, the column player should pay the row player about 38 cents to play. 
\newpage
\section{Number of independent sets}
\begin{itemize}
\item How many independent sets are there on a graph that is a line on $n$ vertices? \\
\\
Suppose with have a line graph with $k-1$ vertexes and have computed the number independent sets it has, $T(k-1)$. Then we add a vertex at the end to obtain $k$ vertices. We can union that vertex with all the independent sets we had before, except for the sets that included the ($k-1$)th vertex. (No set may include both vertices $k-1$ and $k$ because there is an edge between them.) \\
That is, we can union the $k$th vertex with all the independent sets we had on a line graph with $k-2$ vertices, including the empty set. Adding that number to the number of sets that \emph{do} include the $(k-1)$th vertex yields the total number for $k$ vertices. \\
Thus a recurrence for the number of independent sets is \\
$T(k) = T(k-1) + T(k-2),\ T(0) = 1,\ T(1) = 2$. \\
\\
This is almost the Fibonacci sequence, just shifted forward by 1, i.e. \\
$T_0 = F_1 = 1,\ T_1 = F_2 = 2, \dots, T_i = F_{i+1}$.
\item How many independent sets are there on a cycle of $n$ vertices? \\
Like the line graph, vertex $v_k$ may not be unioned with any independent set that include $v_{k-1}$. In addition, it may not be unioned with any set that includes $v_1$.
\item How many independent sets are there on a complete binary tree? \\
Suppose a complete binary tree has $2^{k-1}$ nodes on its bottom row, and $n = 2^{k} - 1$ nodes total. Adding another level adds $2^{k}$ nodes. That row by itself has $2^{2^{k}}$ subsets including the empty set (the power set of $2^{k}$ items). All of them are independent sets in the tree because no edge connects nodes at a given level. Therefore we may construct new independent sets by unioning all subsets of the bottom row (level $k$) with all independent sets of the tree that do not include nodes from level $k-1$. \\
\\
We also must add the number of independent sets that \emph do include the nodes at level $k-1$. \\
\\
Finally there are independent sets that include nodes from both level $k-1$ and level $k$, but a parent and its children can never be in the same independent set. I do not know how to count those. Therefore the recurrence below does not include this last group of independent sets. \\
\\
$T(2^{k+1} - 1) \ge 2^{2^{k}}(T(2^{k-1} - 1) + (T(2^{k} - 1) - T(2^{k-1} - 1))$ \\
$T(0) = 1, T(1) = 2, T(3) = 5$.

\end{itemize}
\end{document}  

\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{epstopdf}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}



\title{}
\author{}
\date{}                                           % Activate to display a given date or no date

\begin{document}
\maketitle
%\section{}
%\subsection{}

\section{Die rolls}
\begin{itemize}
\item{
Explain how to use biased die rolls to generate unbiased coin flips, and determine the expected number of die rolls until a coin flip is generated.
\\
\\
On each roll of the die, if one of the lower three numbers $\{1,2,3\}$ comes up consider it heads, and if one of the upper three numbers $\{4,5,6\}$ comes up consider it tails.\\
Let $p_1, p_2, p_3, q_4, q_5, q_6$ denote the unknown probabilities of rolling each value in $\{1,2,3,4,5,6\}$ respectively. Then on a single die roll the probability of heads is $p = p_1 + p2 + p3$ and the probability of tails is $q = q_4 + q_5 + q_6$.
\\
\\
From here use the methods described in the lecture on coin flips, substituting pairs of die rolls for pairs of coin flips. Since this uses the same number of real rolls (two for each round) as the coin flip methods, the expected number of rolls to get an unbiased flip is the same. For example, using the von Neumann method requires $1/pq$ rolls on average. Note that the substitution of rolls for flips only matters at Level 0; after that the recorded ``heads'' and ``tails'' values are derived from previous results.
\\
\\
As discussed in lecture, the Advanced Multi-Level strategy is the best we can do, under the assumption that we're mapping the die values into heads and tails as described above. So the expected number of rolls to get a flip is $1/A(p)$, where $A(p)$ is the average number of flips generated by a roll:
\begin{equation*}
A(p) = pq + \frac{1}{2}A(p^{2} + q^{2}) + \frac{1}{2}(p^{2} + q^{2})A\left( \frac{p^{2}}{p^{2} + q^{2}} \right)
\end{equation*}
}
\newpage
\item{Explain how to use biased die rolls to generate unbiased die rolls, and determine the expected number of die rolls until an unbiased die roll is generated.
\\
\\
We need to generate 6 outcomes with equal probability. Begin by generating unbiased coin flips using the method described above, calling a real die roll ``heads'' if it is in the set $\{1,2,3\}$ and ``tails'' if it is in $\{4,5,6\}$, and then proceeding with the Advanced Multi-Level strategy.
\\
\\
Let the final sequence of unbiased coin flips obtained by the Advanced Multi-Level strategy be called $D0$. Now for every sequence of three unbiased coin flips in $D0$, assign a die roll as follows:
\\
\\
\begin{tabular}{r @{ = } l}
{H H T} & 1 \\
{H T H} & 2 \\
{H T T} & 3 \\
{T T H} & 4 \\
{T H T} & 5 \\
{T H H} & 6 \\
\end{tabular}
\\
\\
Notice that there are two additional three-flip sequences we could obtain, H H H and T T T. If we instead looked at two-flip sequences there would only be four possible permutations and we need six; three-flip sequences do the job with some wasted flips.
\\
To recycle this waste start another level of flips, $D1$. When H H H appears, send it to $D1$ as H, and when T T T appears send to to $D1$ as T. 
\\
\\
\begin{tabular}{l r r r r r r r r}
{$D0$: } & {T H H} & {H H H} & {T T H} & {H T H} & {T T T} & {H T T} & {T H H} & {H H H} \\
 & 6 &  & 4 & 2 & & 3 & 6 & \\
 \\
 {$D1$: } & & H & & & T& & & H \\
 & & & & & & & & 2
\end{tabular}
\\
\\
For every third entrant into $D1$, check if it completes one of the sequences assigned to $\{1,\dots,6\}$ above and if so record a die roll. Note that sequences H H H and \\T T T may appear in $D1$. In theory we could send those to a $D2$, and continue down as many levels deep as desired, but for simplicity I will cut it off at $D1$.
\\
\\
Recall that the expected number of rolls to get an unbiased coin flip is $1/A(p)$, with $A(p)$ defined above for the Advanced Multi-Level strategy. How does this unbiased die roll method above modify that?
\\
Since each coin flip is unbiased, the probability of any three-flip sequence is $(1/2)^{3}$. In $D0$ there are six such sequences that give us a die roll, so the expected number of flips to get one unbiased die roll from $D0$ is $3 * 6 * (1/2)^{3} = 9/4$.
\\
\\
Furthermore, there are two three-flip sequences that get sent to $D1$. It requires nine flips in $D0$ to generate a three-flip $D1$ sequence. Once in $D1$ though there are again six sequences that may be used as die rolls, and they each occur in $D1$ with probability $(1/2)^{3}$.
\\
\\
Therefore the total expected number of unbiased coin flips to get an unbiased die roll is
\begin{align*}
(3 * 6 * (1/2)^{3}) + \left ( 9 * 2 * {\left (\frac{1}{2} \right )}^{3} \right ) * (6 * (1/2)^{3}) \\
= (9/4) + (9/4) * (6/8) = 3 \frac{15}{16}
\end{align*}
\\
Finally, scaling that value by the expected number of biased die rolls to obtain the coin flips in the first place yields
\begin{equation*}
\frac {3 \frac{15}{16}}{A(p)}
\end{equation*}
}
\end{itemize}

\newpage

\section{Fibonacci}
First, here are the results for unmodified Fibonacci numbers (i.e. not modulo $2^{16}$):
\begin{table}[h]
\begin{tabular}{c c c c c c c c c}
type & \multicolumn{5}{c}{time in seconds for input size}\\ \hline
& 10 & 20 & 30 & 40 & 46 & 50 & 1,000,000 & 1,000,000,000\\ \hline
recursive & 0.000009 & 0.000384 & 0.027792 & 3.046521 & 54.833702 & 386.283041 & - & - \\
iterative & 0.000005 & 0.000006 & 0.000006 & 0.000007 & 0.000007 & 0.000007 & 0.009328 & - \\
matrix & 0.000006 & 0.000007 & 0.000008 & 0.000008 & 0.000008 & 0.000008 & 0.021418 & 18.483397 \\
\end{tabular}
\caption{Computation times, unmodified Fibonacci numbers}
\end{table}

$F_{47}$ is the first Fibonacci number where I reach integer overflow. The table includes a few larger inputs although it is unclear what the times mean after reaching integer overflow. \\
Because the recursive method took over 6 minutes at input size 50 I did not attempt a larger input. \\
The iterative method is faster than the matrix method at input size 1,000,000 but I could not test much larger inputs because it has a segmentation fault starting around 2,000,000.
\\
\\
Next the results when returning Fibonacci numbers modulo $2^{16}$:
\begin{table}[h]
\begin{tabular}{c c c c c c c c c c}
type & \multicolumn{5}{c}{time in seconds for input size}\\ \hline
& 10 & 20 & 30 & 40 & 46 & 47 & 50 & 2,147,483,647 \\ \hline
recursive & 0.000008 & 0.000310 & 0.030085 & 3.319581 & 59.460677 & 97.513431 & 407.096453 & - \\
iterative & 0.000006  & 0.000006 & 0.000007 & 0.000007 & 0.000006 & 0.000006 & 0.000007 & -  \\
matrix & 0.000006 & 0.000006 & 0.000007 & 0.000007 & 0.000007 & 0.000006 & 0.000007 & 33.651842 \\
\end{tabular}
\caption{Computation times, Fibonacci numbers modulo $2^{16}$}
\end{table}

With the iterative method, it is not possible to determine the largest Fibonacci number (modulo $2^{16}$) computable in one minute because it has a segmentation fault after around 2,000,000, and processing 2,000,000 takes only 0.02 seconds. \\
With the matrix method, using int variables I can only attempt up to 2,147,483,647, which computes in 34 seconds.

See page \pageref{fibcode} for the source code.

\section{Relationship between expressions A and B}
\begin{tabular}{c c | c | c | c | c | c } 
$A$ & $B$ & $O$ & $o$ & $\Omega$ & $\omega$ & $\Theta$ \\ \hline
$log\,n$ & $log(n^{2})$ & yes & no & yes & no & yes \\ \hline
$log(n!)$ & $log(n^{n})$ & yes & no & yes & no & yes \\ \hline
$\sqrt[3]{n}$ & $(log\,n)^{6}$ & no & no & yes & yes & no \\ \hline
$n^{2}2^{n}$ & $3^{n}$ & yes & no & no & no & no \\ \hline
$(n^{2})!$ & $n^{n}$ & yes & no & yes & no & yes \\ \hline
$\frac {n^{2}}{log\,n}$ & $n\,log(n^{2})$ & no & no & yes & yes & no \\ \hline
$(log\,n)^{log\,n}$ & $\frac {n}{log(n)}$ & no & no & yes & yes & no \\ \hline
$100n + log\,n$ & $(log\,n)^{3} + n$ & yes & no & yes & no & yes \\ \hline
\end{tabular}

\newpage

\section{Big-Oh related proofs}
\begin{itemize}
\item{Let $f_1(n) = n$. Then $f_1(2n)$ is $O(f_1(n))$. \\
Proof by Definition: \\
Let $c = 2$. Then $\forall\,n\, \ge 1\, f_1(2n) = 2n \le c * f_1(n)  = 2n$.  }
\item{Let $f_2(n) = 2^{n}$. Then $f_2(2n)$ is not $O(f_2(n))$. \\
Proof by Contradiction: \\
Suppose $f_2(2n)$ is $O(f_2(n))$. Then $\exists c, N$ such that $\forall \,n > N, f_2(2n) \le c * f_2(2n)$. \\
That is, $\forall \, n \ge N\ 2^{2n} = 4^{n} \le c * 2^{n}$. \\
It follows that $\forall \, n \ge N \frac{4^{n}}{c2^{n}} \le 1$, and thus $\lim_{n\to\infty} \frac{4^{n}}{c2^{n}} \le 1$. \\
This is a contradiction, because  \\
$\lim_{n\to\infty} \frac{4^{n}}{c2^{n}} = \lim_{n\to\infty}  \frac{1}{c} {\left ( \frac{4}{2} \right )}^{n} =  \frac{1}{c} \lim_{n\to\infty} 	2^{n} = \infty$.
}
\item{If $f(n)$ is $O(g(n))$, and $g(n)$ is $O(h(n))$, the $f(n)$ is $O(h(n))$. \\
Proof by Definition: \\
By assumption, \\
$\exists c_1, N_1$ such that $\forall n \ge N_1,\, f(n) \le c_1 * g(n)$. \\
$\exists c_2, N_2$ such that $\forall n \ge N_2,\, g(n) \le c_2 * h(n)$. \\
\\
Let $c_3 = max(c_1, c_2)$ and $N_3 = max(N_1, N_2)$. It follows that \\
$\forall n \ge N_3,\ f(n) \le c_3 g(n) \le c_3 * c_3 h(n)$. \\
This satisfies the definition for $f(n)$ to be $O(h(n))$. 
}
\item {
Statement: If $f$ is not $O(g)$, then $g$ is $O(f)$. \\
This is false. Take as a counterexample
\begin{flalign*}
f(n) &= 2^{n} \text{ and }
g(n) = \begin{cases}
4^{n}, & \mbox{if } n \mbox{ is odd} \\
4^{-n}, & \mbox{if } n \mbox{ is odd}
\end{cases} & \\
\end{flalign*}
}
\item {
Statement: If $f$ is $o(g)$, then $f$ is $O(g)$. \\
This is true. Since $f$ is $o(g)$, by definition $\lim_{n\to\infty} \frac{f}{g} = 0$. By the definition of a limit, it follows that $\forall \epsilon > 0, \exists N$ such that $\forall n \ge N, f/g < \epsilon$. \\
Take an arbitrary $\epsilon > 0$, call it $c = \epsilon_1$. $\exists N_1$ such that $\forall n \ge N_1, f/g \le c$. That is, $\forall n \ge N_1, f \le cg$, because $f$ and $g$ are positive valued functions. This meets the definition that $f$ is $O(g)$.
}
\end{itemize}
\newpage

\section{StoogeSort}

This algorithm should work as follows: \\
Let $L$ be an unsorted list of size $n$, with indices [0,1,...,n-1]. Let $A$ be a sublist of $L$ that ranges from index $a$ to $b$. \\
\\
Starting with $A = L$, divide $A$ into three roughly equal sublists: \\
First create cut points: Let $j =  \lfloor \frac{b-a}{3} \rfloor $ and let $k =  \lceil 2 * ( \frac{b-a}{3}) \rceil$. \\
Then let $A_1$ have indices $[a, \dots, j]$, let $A_2$ have indices $[j, \dots, k]$, and let $A_3$ have indices $[k, \dots, b]$. \\
If $n$ is not divisible by 3 the sizes of $A_1, A_2, A_3$ may differ by up to 2, with the middle portion $A_2$ being larger.
\\
\\
Sort as described in the homework: Sort $A_1 \cup A_2$, then sort $A_2 \cup A_3$, then sort $A_1 \cup A_2$ again.  \\
The base cases are when the size of the partial list currently under consideration (say  $A_1 \cup A_2$) has size 1 or 2. Sort these directly: If there are two elements swap them if necessary and return, if one element simply return. Otherwise the partial list has size 3 or more. Recursively StoogeSort it.
\\
\\
Proof of correctness: \\
For any sublist $A$, after the first phase of StoogeSort the lower $2/3$ of the list is sorted, meaning $\forall a_1 \in A_1, \forall a_2 \in A_2, a_1 \le a_2$.
\\
\\
After the second phase, the upper $2/3$ of the list is sorted, meaning $\forall a_2 \in A_2, \forall a_3 \in A_3, a_2 \le a_3$. \\
Note also that, by the combination of the first and second phases, $\forall a_1 \in A_1, \forall a_3 \in A_3, a_1 \le a_3$. Since $A_3$ is internally sorted, and everything in $A_3$ is at least as big as everything in the lower $2/3$ of the list, $A_3$ has its final sort order.
\\
\\
The only possibly unsorted items remaining will be items that started in $A_3$ and have moved down to $A_2$ during the second phase. Specifically, some of those elements may be smaller than some items in $A_1$. The third phase re-sorts $A_1 \cup A_2$, which puts any such elements in their proper order, and the list is fully sorted.
\\
\\
This works even when $n$ is not divisible by 3 because of the``floored'' and ``ceilinged'' cut points. They make it so $A_2$ has at least as many elements as $A_1$ and $A_3$. That guarantees that over the three phases of StoogeSort every element is compared.
\\
\\
A recurrence relation for this algorithm is $T(1) = T(2) = 1, T(n) = 3T(\lceil \frac{2n}{3} \rceil)$. Carrying this out gives
\begin{align*}
T(n) &= 3T(\lceil \frac{2n}{3} \rceil) \\
&= 3^{2}T(\lceil \frac{4n}{9} \rceil) \\
&= 3^{3}T(\lceil \frac{8n}{27} \rceil) \\
& \cdots \\
&= 3^{log_{3/2}n + 1 - log_{3/2}3}
\end{align*}

because ${\left ( \frac{2}{3} \right )}^{x} n = 2$ when $x = 3^{log_{3/2}n + 1 - log_{3/2}3}$. This calculation is a bit rough because of the ceiling in $T(\lceil {\left ( \frac{2}{3} \right )}^{x} n \rceil)$. It is not exactly correct to raise $\frac{2}{3}$ to a higher power on each step, but it is an estimate. In any case StoogeSort is $O(3^{log\,n})$.

%\newpage

\section{Solve recurrences}
\begin{itemize}
\item{$T(1) = 1, T(n) = T(n-1) + 3n - 3$ \\
Solution: $T(n) = 1 + \frac{3}{2}(n^{2} - n)$ \\
Proof by Induction: \\
Base case: $T(1) = 1 + \frac{3}{2}(1^{2} - 1) = 1 + 0	= 1$ \\
Inductive Hypothesis: $T(k) = 1 + \frac{3}{2}(k^{2} - k)$ \\
The recurrence relation states that $T(k+1) = T(k) + 3(k+1) - 3$. Substituting in the assumed value of $T(k)$ yields
\begin{flalign*}
T(k+1) &= 1 + \frac{3}{2}(k^{2} - k) + 3(k+1) - 3 \\
&= 1 + \frac{3}{2}(k^{2} - k) +  \frac{3}{2}(2k) + 3 - 3 & \\
&= 1 + \frac{3}{2}(k^{2} - k + 2k) & \\
&= 1 + \frac{3}{2}(k^{2} + k) & \\
&= 1 + \frac{3}{2}(k(k + 1)) & \\
&= 1 + \frac{3}{2}((k + 1 -1)(k + 1)) & \\
&= 1 + \frac{3}{2}((k + 1)^{2} - (k + 1)) \  \blacksquare & \\
\end{flalign*}
}
\item{$T(1) = 1, T(n) = 2T(n-1) + 2n - 1$ \\
Solution:
\begin{equation*}
T(n) = 2^{n-1} + \sum_{i=0}^{n-2} 2^{i} (2(n-i) - 1)
\end{equation*}
Proof by induction: \\
Base cases: \\
$n = 1$: $2^{0} = 1$. The sum portion is indexed from $i=0$ to $i=-1$, so it contributes nothing. \\
$n = 2$: $2^{1} + 2^{0}(2(2-0) - 1) = 5$. \\
These match the values obtained by the recurrence.
\\
\\
Inductive Hypothesis:  
\begin{equation*}
T(k) = 2^{k-1} + \sum_{i=0}^{k-2} 2^{i} (2(k-i) - 1)
\end{equation*}
}
The recurrence relation states that $T(k+1) = 2T(k) + 2(k+1) - 1$.  Substituting in the assumed value of $T(k)$ yields
\begin{align*}
T(k+1) &= 2 \left [ 2^{k-1} + \sum_{i=0}^{k-2} 2^{i} (2(k-i) - 1) \right ] + 2(k+1) - 1 \\
& \text{Distributing the 2 over the bracketed sum yields the following:} & \\
&= 2^{k} + \sum_{i=1}^{k-1} 2^{i} (2(k+1-i) - 1) + 2(k+1) - 1 & \\
&  \text{Note that k is bumped up by 1. The  2(k+1) - 1 may be moved into the sum} & \\
&= 2^{k} + \sum_{i=0}^{k-1} 2^{i} (2(k+1-i) - 1) & \\
& \text{because when $i = 0$, $2^{i} (2(k+1-i) - 1) = 2(k+1) - 1$. Thus we have} & \\
&= 2^{(k+1) - 1} + \sum_{i=0}^{(k+1)-2} 2^{i} (2(k+1-i) - 1) &
\blacksquare
\end{align*}
\end{itemize}

\section{Asymptotic bounds for $T(n)$}
\section{Generalized recurrence, $T(n) = T( \lceil n/2 \rceil ) + T( \lfloor n/2 \rfloor ) + n - 1$ }
\newpage
\section{Fibonacci code} \label{fibcode}

\begin{verbatim}
/*
 * Problem 2: Three Fibonacci computation methods
 * A macro, DO_MOD, controls whether the methods return the real Fibonacci 
 * numbers or the Fibonacci numbers modulo 2^16.
 * Edit macro value and recompile to switch.
 */

#include <stdio.h>
#include <time.h>

// change to DO_MOD 0 to return unmodifed Fibonacci numbers
#define DO_MOD 1

#if DO_MOD
#define MODULO % 65536
#endif

#ifndef MODULO
#define MODULO 
#endif

int fib_rec(int n);
int fib_iter(int n);
int fib_mat(int n);

/* helper methods */
void raise_fib_matrix(int n, int prodm [2][2]);
void matrix_mult_2x2(int m1 [2][2], int m2 [2][2], int prodm [2][2]);


int main() {
    printf("Fibonacci Demonstration\n\n");
    printf("Warning: no input validation\n\n");

    printf("Which computation method?\n");
    printf("Recursive, Iterative, or Matrix (r|i|m): ");
    char ch;
    scanf("%c", &ch);

    printf("Enter N: ");
    int n;
    scanf("%i", &n);
    
    clock_t start, end;
    double cpu_time_used;
    
    printf("\n");
    if (ch == 'r') {
        start = clock();
        printf("%i", fib_rec(n));
        end = clock();
    }
    else if (ch == 'i') {
        start = clock();
        printf("%i", fib_iter(n));
        end = clock();
    }
    else if (ch == 'm') {
        start = clock();
        printf("%i", fib_mat(n));
        end = clock();
    }
    else {
        printf("Invalid option. Exiting.");
        return 1;
    }

    printf("\n\n");
    printf("clock cycles: %f\n", (double) (end - start));
    printf("CLOCKS_PER_SEC: %d\n", (int) CLOCKS_PER_SEC);
    cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;
    printf("cpu time used in seconds : %f \n\n", cpu_time_used);

    return 0;
}

/* 
 * fib_rec - recursively compute the nth Fibonacci number
 */
int fib_rec(int n) {
    if (n == 0 || n == 1)
        return n;
    return (fib_rec(n-1) + fib_rec(n-2)) MODULO;
}

/*
 * fib_iter - iteratively compute the nth Fibonacci number with an array
 */
int fib_iter(int n) {
    int arr[n];
    arr[0] = 0;
    arr[1] = 1;
    int i;
    for (i = 2; i <= n; i++) {
        arr[i] = (arr[i-1] + arr[i-2]) MODULO;
    }
    return arr[n];
}

/*
 * fib_mat - compute nth Fibonacci number using matrix multiplication
 * Note: this function is the same when calculating modulo 2^16.
 * The only change is to matrix_mult_2x2, below.
 */
int fib_mat(int n)  {

    if (n == 0 || n == 1)
        return n;

    // product of fibonacci matrix raised to nth power
    int prodm [2][2];
    raise_fib_matrix(n, prodm);

    // fn = (prodm[0][0] * 0) + (prodm[0][1] * 1);
    int fn = prodm[0][1];
    // do not need to calculate fn+1
    // int fn+1 = (prodm[1][0] * 0) + (prodm[1][1] * 1);
    return fn;
}

/* helper methods for fib_mat */

/* 
 * raise_fib_matrix
 * raise fibonacci matrix to nth power
 * put result in prodm
 */
void raise_fib_matrix(int n, int prodm [2][2]) {
    int fibm [2][2];
    fibm[0][0] = 0;
    fibm[0][1] = 1;
    fibm[1][0] = 1;
    fibm[1][1] = 1;

    /* first populate result with the fibonacci matrix to the 1st power */
    prodm[0][0] = 0;
    prodm[0][1] = 1;
    prodm[1][0] = 1;
    prodm[1][1] = 1;

    /* populate result with fibonacci matrix to the nth power */
    int i;
    for (i = 1; i < n; i++) // does not run when n == 1
        matrix_mult_2x2(fibm, prodm, prodm);

    return;
}

/*
 * matrix_mult_2x2
 * multiply two dimensional arrays m1 and m2 
 * caller must provide prodm in which to store the product
 */
void matrix_mult_2x2(int m1 [2][2], int m2 [2][2], int prodm [2][2]) {
    int a00, a01, a10, a11;
    
    a00 = ( (m1[0][0] * m2[0][0]) + (m1[0][1] * m2[1][0]) ) MODULO;
    a01 = ( (m1[0][0] * m2[0][1]) + (m1[0][1] * m2[1][1]) ) MODULO;
    a10 = ( (m1[1][0] * m2[0][0]) + (m1[1][1] * m2[1][0]) ) MODULO;
    a11 = ( (m1[1][0] * m2[0][1]) + (m1[1][1] * m2[1][1]) ) MODULO;

    prodm[0][0] = a00;
    prodm[0][1] = a01;
    prodm[1][0] = a10;
    prodm[1][1] = a11;

    return;
}

\end{verbatim}

\end{document}  
